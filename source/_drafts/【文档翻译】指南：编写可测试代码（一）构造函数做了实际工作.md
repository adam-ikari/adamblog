---
title: 【文档翻译】指南：编写可测试代码（一）把构造函数作为执行实际操作的地方是有缺陷的（Flaw：Constructor does real work）
toc: true
categories:
  - 文档翻译
date: 2023-02-28 12:28:47
keywords:
  - 编写可测试代码 
  - 测试
  - 单体测试
  - 谷歌最佳实践
  - misko hevery
description: 翻译 misko hevery 的 Guide Writing Testable Code
tags:
  - 编写可测试代码
cover:
---

## 摘要

这是一个常见的问题：某些开发人员会为他们的类写入大量的代码，而这些代码不是作为构造函数的必要工作。从概念上讲，构造函数应该完成对象初始化的工作，并确保对象处于一致的状态，以便立即对其进行操作。

一个常见的例子是，一个人可能在构造函数内打开一个数据库连接、填充几个缓存，或者对任何其他的I / O操作，都有可能会发生异常情况。 这些操作会使得对象处于不稳定的状态，如何处理这些异常情况，也很有可能与调用者的预期不符。这种缺乏清晰界限和目的的构造函数，将影响代码的可测试性，可重用性和理解性。

我们的解决方法是，将构造函数的工作范围只限于初始化对象的所有字段，而不执行实际的操作。任何需要进行磁盘或网络I / O或其他会抛出异常的操作，都应该移动到明确可见的方法之中。这个新建的方式使对象更容易理解，更容易测试，并且更容易进行事件处理。

<!--more-->

## 正文

在构造函数中进行以下工作，如创建/初始化协作对象、与其他服务通信以及设置自身状态的逻辑，会破坏测试所需的接缝，强制子类/模拟继承不需要的行为。构造函数中太多的工作会妨碍在测试中实例化或修改协作对象。

**警告标志：**

- 在构造函数或字段声明中使用new关键字
- 在构造函数或字段声明中调用静态方法
- 构造函数中的操作不止是字段赋值
- 对象在构造函数结束前未完全初始化（请注意初始化方法）
- 构造函数中使用了流程控制（条件或循环逻辑）
- 构造函数中进行了复杂的对象图构建，未使用工厂模式或建造者模式
- 添加或使用初始化块

### 为什么这是一个缺陷

构造函数需要实例化和初始化协作者时，这通常会导致设计不够灵活和过早耦合。这样的构造函数会使得在测试时注入测试协作者的能力无法实现。

> 建议设计构造函数时避免过度耦合以提高灵活性，并允许在测试过程中注入测试协作者。

### 违反单一职责原则

将协作者的构造函数和初始化混合在一起，这表明只有一种方式可以配置类，这失去了可能存在的其他重用机会。对象图构建是一个完整的责任，与类最初存在的原因不同。在构造函数中完成此类工作违反了单一职责原则。

> 建议将协作者的构造函数和初始化分开来，以支持更多的配置方式和重用机会，同时遵循单一职责原则，确保每个类的责任单一且明确。

### 直接进行测试较为困难

测试这样的构造函数是困难的，因为要实例化对象必须执行构造函数。如果构造函数做了很多工作，当在测试中创建对象时，就会被迫执行这些工作。如果协作者访问外部资源（例如文件、网络服务或数据库），则协作者中微妙的更改可能需要反映在构造函数中，但可能会因缺少测试覆盖而被忽略。这些情况下，对该构造函数进行测试是如此困难，以至于某些测试未被执行，而我们又陷入了一个恶性循环。

### 通过子类化和重载来进行测试仍存在瑕疵

有时构造函数本身的工作很少，而是委托给一个方法，这个方法被期望在测试子类中被重写。这可能解决了构建困难的问题，但使用“子类测试”技巧是你只应该作为最后的手段来做的。另外，通过子类化，你将无法测试你重写的方法。而那个方法做了大量工作（记住 - 这就是为什么它在第一次被创建时），所以它可能应该被测试。


